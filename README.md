# EMG Signal Processing Pipeline (Draft)

**pyemgpipeline** is an electromyography (EMG) signal processing pipeline package.
The package is suitable for both surface EMG and fine wire EMG.
The suggested minimum sample rate is 1000 hz for surface EMG
and 2000 hz for fine wire EMG.

The EMG processing steps considered in this package include
DC offset removal, bandpass filtering, full wave rectification, linear envelope,
end frame cutting, amplitude normalization, and segmentation.

## Overview

**pyemgpipeline** contains modules `processors`, `wrappers`, and `plots`.

Module `processors` includes the base class `BaseProcessor` of all signal
processors and seven classes for different processing steps:
`DCOffsetRemover`, `BandpassFilter`, `FullWaveRectifier`, `LinearEnvelope`,
`EndFrameCutter`, `AmplitudeNormalizer`, and `Segmenter`.

Module `wrappers` includes three wrapper classes to facilitate the signal
processing by integrating data and individual processors.
Class `EMGMeasurement` works for data of a single trial,
class `EMGMeasurementCollection` works for data of multiple trials,
and class `DataProcessingManager` intents to fix the correct sequence of
processing steps so the users cannot do it wrong.

Module `plots` includes
the function `plot_emg` to plot EMG signals on `matplotlib` figures
and the class `EMGPlotParams` to manage the plot-related parameters.

## Documentation

The API reference is available here.
There are also examples provided to demonstrate the usage of this package.

## Installation

**pyemgpipeline** can be installed from the PyPI repository:

```
pip install pyemgpipeline
```

The dependencies of this package include `numpy`, `scipy`, and `matplotlib`.

## Quick Start

#### Data preparation

Prepare signal data of each trial as a 2d ndarray with shape
_(n_samples, n_channels)_,
where each column represents data of one channel.
If only one channel is presented, it can also be stored as
a 1d ndarray with shape _(n_samples,)_.

Prepare timestamp data of each trial as a 1d ndarray with shape
_(n_samples,)_.
If timestamp data is not provided, it will be generated by the
package, starting from 0 and in increments of _1/hz_,
where _hz_ is the sample rate.

#### Sample code

```
>>> import numpy as np
>>> import pyemgpipeline as pep
>>> all_data = [
...     np.array([20.3, 41.0, 53.9, 63.3, 39.5, 24.9, 26.1, 24.0, 44.1, 42.0,
...               37.4, 24.6, -21.8, -56.3, -48.1, -45.0, -29.1, -9.6, 5.3, 1.4]),
...     np.array([1.1, 2.9, 1.4, -0.2, 4.4, 7.2, 9.9, 19.1, 14.2, 18.8,
...               17.2, 17.9, 11.1, 13.9, 15.4, 19.4, 12.1, 16.9, 12.4, 9.0])
... ]
>>> hz = 1000
>>> mgr = pep.wrappers.DataProcessingManager()
>>> mgr.set_data_and_params(all_data, hz=hz, all_main_titles=['trial 1', 'trial 2'])
>>> mgr.set_end_frame_cutter(pep.processors.EndFrameCutter(n_end_frames=0))
>>> c = mgr.process_all(is_plot_processing_chain=True)
```

#### Results

Intermediate results during the whole processing steps can be visualized in figures.
For example, the figure below shows the result of trial 1 after the bandpass filter
step is done.

![example figure](doc/assets/fig_ex_in_quick_start.png)

[comment]: <> (<p align="center">)
[comment]: <> (<img src="doc/assets/fig_ex_in_quick_start.png" alt="example figure" width="400">)
[comment]: <> (</p>)

The final processed signals are stored in `c.all_data`.

## Community Guidelines

- Contribution

- Reporting issues

- Support

## Citation

If you use this package in your project, please cite this.


